{
    // Place your ssm-teacher-mobile-app workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }

    // generator api with hook function for api normal
    "genApiHook": {
        "prefix": "genApiHook",
        "body": [
            "import { ResponseModel } from 'app/models/common';",
            "import { useCallback, useState } from 'react';",
            "interface IParams {",
            "    params: IParams$1,",
            "    withoutLoading?: boolean,",
            "    onSuccess?: (data?: any) => void,",
            "    onFailed?: (error?: any) => void,",
            "}",
            "export interface IParams$1 {",
            "",
            "}",
            "",
            "// =====",
            "export const use$1 = () => {",
            "    // const save = useSave()",
            "    const [data, setData] = useState<$2>()",
            "    const [isLoading, setIsLoading] = useState(false);",
            "    const [error, setError] = useState(null);",
            "",
            "    const fetch = useCallback(async (currentParams?: IParams) => {",
            "        !currentParams?.withoutLoading && setIsLoading(true)",
            "        try {",
            "            const response = await handlerFrist.takeLatest($3(currentParams?.params))",
            "            setData(response?.data)",
            "            currentParams?.onSuccess?.()",
            "        } catch (error: any) {",
            "            if (!error?.canceled) {",
            "                setError(error?.message)",
            "                currentParams?.onFailed?.()",
            "            }",
            "        } finally {",
            "            !currentParams?.withoutLoading && setIsLoading(false)",
            "        }",
            "    }, [])",
            "",
            "    return {",
            "        fetch,",
            "        data,",
            "        isLoading,",
            "        error,",
            "    }",
            "}",
            "",
            "interface IPromiseCancel<T> {",
            "    promise: Promise<T>;",
            "    canceled: (reason?: any) => void;",
            "}",
            "",
            "const promiseCancelable = <T,>(promise: Promise<T>) => {",
            "    let rejectRoot: (reason?: any) => void = () => null;",
            "",
            "    const promiseResult: Promise<T> = new Promise((resolve, reject) => {",
            "        rejectRoot = reject;",
            "        promise.then((res) => resolve(res)).catch(error => {",
            "            reject(error);",
            "        })",
            "    })",
            "",
            "    return {",
            "        promise: promiseResult,",
            "        canceled: rejectRoot,",
            "    }",
            "}",
            "",
            "class PromiseHandler {",
            "    excutor: null | IPromiseCancel<ResponseModel<$2>>",
            "    constructor() {",
            "        this.excutor = null;",
            "    }",
            "",
            "    takeLatest(promise: Promise<any>) {",
            "        !!this?.excutor?.canceled && this.excutor.canceled();",
            "        this.excutor = promiseCancelable(promise);",
            "",
            "        return this.excutor.promise;",
            "    }",
            "}",
            "",
            "// =====",
            "const handlerFrist = new PromiseHandler();",
            ""
        ],
        "description": "genApiHook"
    },
    // generator api with hook function for api paging
    "genApiHookPaging": {
        "prefix": "genApiHookPaging",
        "body": [
            "import { ResponseModel } from 'app/models/common';",
            "import { IPagingRequest } from 'app/models/request/IPagingRequest';",
            "import { useCallback, useState } from 'react';",
            "interface IParams {",
            "    params: IParams$1,",
            "    withoutLoading?: boolean,",
            "    onSuccess?: (data?: any) => void,",
            "    onFailed?: (error?: any) => void,",
            "}",
            "export interface IParams$1 extends IPagingRequest {",
            "",
            "}",
            "",
            "// =====",
            "export const use$1 = () => {",
            "    // const save = useSave()",
            "    const [data, setData] = useState<$2[] | undefined>()",
            "    const [isLoading, setIsLoading] = useState(false);",
            "    const [isFetching, setIsFetching] = useState(false);",
            "    const [error, setError] = useState(null);",
            "    const [hasMore, setHasMore] = useState(false);",
            "",
            "    const fetchRefresh = useCallback(async (currentParams: IParams) => {",
            "        !currentParams?.withoutLoading && setIsLoading(true)",
            "        try {",
            "            const response = await handlerFrist.takeLatest($3(currentParams.params))",
            "            setData(response?.data ?? undefined)",
            "            setHasMore(Boolean(response?.data?.meta?.pagination?.links.next))",
            "            currentParams?.onSuccess?.()",
            "        } catch (error: any) {",
            "            if (!error?.canceled) {",
            "                setError(error?.message)",
            "                currentParams?.onFailed?.()",
            "            }",
            "        } finally {",
            "            !currentParams?.withoutLoading && setIsLoading(false)",
            "        }",
            "    }, [])",
            "",
            "    const fetchMore = useCallback(async (currentParams: IParams) => {",
            "        !currentParams?.withoutLoading && setIsFetching(true)",
            "        try {",
            "            const response = await handlerMore.takeLatest($3(currentParams.params))",
            "            if (Array.isArray(response?.data?.data) && response?.data?.data?.length > 0) {",
            "                setData((prev?: $2[]) => {",
            "                    if (Array.isArray(prev)) return [...prev, ...response?.data?.data]",
            "                    return prev",
            "                })",
            "            }",
            "            setHasMore(Boolean(response?.data?.meta?.pagination?.links.next))",
            "            currentParams?.onSuccess?.()",
            "        } catch (error: any) {",
            "            if (!error?.canceled) {",
            "                setError(error?.message);",
            "                currentParams?.onFailed?.()",
            "            }",
            "        } finally {",
            "            !currentParams?.withoutLoading && setIsFetching(false)",
            "        }",
            "    }, [])",
            "",
            "    const fetchApi = useCallback(async (currentParams: IParams) => {",
            "        if (currentParams?.params?.page > 1) {",
            "            fetchMore(currentParams)",
            "        } else {",
            "            fetchRefresh(currentParams)",
            "        }",
            "    }, [fetchRefresh, fetchMore])",
            "",
            "    return {",
            "        fetchApi,",
            "        hasMore,",
            "        data,",
            "        isLoading,",
            "        isFetching,",
            "        error,",
            "    }",
            "}",
            "",
            "interface IPromiseCancel<T> {",
            "    promise: Promise<T>;",
            "    canceled: (reason?: any) => void;",
            "}",
            "",
            "const promiseCancelable = <T,>(promise: Promise<T>) => {",
            "    let rejectRoot: (reason?: any) => void = () => null;",
            "",
            "    const promiseResult: Promise<T> = new Promise((resolve, reject) => {",
            "        rejectRoot = reject;",
            "        promise.then((res) => resolve(res)).catch(error => {",
            "            reject(error);",
            "        })",
            "    })",
            "",
            "    return {",
            "        promise: promiseResult,",
            "        canceled: rejectRoot,",
            "    }",
            "}",
            "",
            "class PromiseHandler {",
            "    excutor: null | IPromiseCancel<ResponseModel<$2[]>>",
            "    constructor() {",
            "        this.excutor = null;",
            "    }",
            "",
            "    takeLatest(promise: Promise<any>) {",
            "        !!this?.excutor?.canceled && this.excutor.canceled();",
            "        this.excutor = promiseCancelable(promise);",
            "",
            "        return this.excutor.promise;",
            "    }",
            "}",
            "",
            "// =====",
            "const handlerFrist = new PromiseHandler();",
            "const handlerRefresh = new PromiseHandler();",
            "const handlerMore = new PromiseHandler();",
            ""
        ],
        "description": "genApiHookPaging"
    }
}
